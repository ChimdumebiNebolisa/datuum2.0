/**
 * Export Utilities for Datuum 2.0
 * 
 * Provides comprehensive export functionality for charts, data, and presentations
 */

import { downloadBlob } from './utils'
import jsPDF from 'jspdf'

export interface ExportOptions {
  filename?: string
  quality?: number
  dpi?: number
  includeMetadata?: boolean
}

export interface ChartExportData {
  chart: HTMLCanvasElement
  title?: string
  data?: any
  config?: any
  metadata?: {
    createdAt: Date
    chartType: string
    dataSource: string
  }
}

export interface DataExportData {
  data: any
  format: 'csv' | 'json' | 'xlsx' | 'tsv'
  filename?: string
}

export interface PresentationExportData {
  charts: ChartExportData[]
  title: string
  description?: string
  includeDataTable?: boolean
  includeInsights?: boolean
}

// Chart Export Functions
export async function exportChartAsPNG(
  chartData: ChartExportData, 
  options: ExportOptions = {}
): Promise<void> {
  const { chart, title, metadata } = chartData
  const { filename = 'chart', quality = 0.9, includeMetadata = true } = options

  const dataUrl = chart.toDataURL('image/png', quality)
  const blob = await dataUrlToBlob(dataUrl)
  
  if (includeMetadata && metadata) {
    // Add metadata to filename
    const timestamp = metadata.createdAt.toISOString().split('T')[0]
    const finalFilename = `${filename}_${metadata.chartType}_${timestamp}.png`
    downloadBlob(blob, finalFilename)
  } else {
    downloadBlob(blob, `${filename}.png`)
  }
}

export async function exportChartAsSVG(
  chartData: ChartExportData, 
  options: ExportOptions = {}
): Promise<void> {
  const { chart, title, metadata } = chartData
  const { filename = 'chart', includeMetadata = true } = options

  // Convert canvas to SVG
  const svg = canvasToSVG(chart, title)
  const blob = new Blob([svg], { type: 'image/svg+xml' })
  
  if (includeMetadata && metadata) {
    const timestamp = metadata.createdAt.toISOString().split('T')[0]
    const finalFilename = `${filename}_${metadata.chartType}_${timestamp}.svg`
    downloadBlob(blob, finalFilename)
  } else {
    downloadBlob(blob, `${filename}.svg`)
  }
}

export async function exportChartAsPDF(
  chartData: ChartExportData, 
  options: ExportOptions = {}
): Promise<void> {
  const { chart, title, metadata } = chartData
  const { filename = 'chart', quality = 0.9 } = options

  try {
    // Create new PDF document
    const pdf = new jsPDF('landscape', 'mm', 'a4')
    const pageWidth = pdf.internal.pageSize.getWidth()
    const pageHeight = pdf.internal.pageSize.getHeight()
    
    // Add title if provided
    if (title) {
      pdf.setFontSize(16)
      pdf.setFont('helvetica', 'bold')
      pdf.text(title, pageWidth / 2, 20, { align: 'center' })
    }
    
    // Convert canvas to image
    const dataUrl = chart.toDataURL('image/png', quality)
    
    // Calculate dimensions to fit chart on page
    const chartWidth = chart.width
    const chartHeight = chart.height
    const maxWidth = pageWidth - 40 // 20mm margin on each side
    const maxHeight = pageHeight - (title ? 60 : 40) // Leave space for title and margins
    
    const scale = Math.min(maxWidth / chartWidth, maxHeight / chartHeight)
    const scaledWidth = chartWidth * scale
    const scaledHeight = chartHeight * scale
    
    const x = (pageWidth - scaledWidth) / 2
    const y = title ? 40 : 20
    
    // Add chart to PDF
    pdf.addImage(dataUrl, 'PNG', x, y, scaledWidth, scaledHeight)
    
    // Add metadata if provided
    if (metadata) {
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')
      const metadataY = y + scaledHeight + 15
      
      pdf.text(`Chart Type: ${metadata.chartType}`, 20, metadataY)
      pdf.text(`Created: ${metadata.createdAt.toLocaleString()}`, 20, metadataY + 5)
      pdf.text(`Data Source: ${metadata.dataSource}`, 20, metadataY + 10)
    }
    
    // Add footer
    const footerY = pageHeight - 10
    pdf.setFontSize(8)
    pdf.text('Generated by Datuum 2.0', pageWidth / 2, footerY, { align: 'center' })
    
    // Save the PDF
    pdf.save(`${filename}.pdf`)
    
  } catch (error) {
    console.error('PDF export failed:', error)
    throw new Error('Failed to export chart as PDF')
  }
}

// Data Export Functions
export async function exportDataAsCSV(
  data: any, 
  options: ExportOptions = {}
): Promise<void> {
  const { filename = 'data' } = options
  
  if (!data?.headers || !data?.rows) {
    throw new Error('No data to export')
  }

  const csvContent = [
    data.headers.join(','),
    ...data.rows.map((row: string[]) => 
      row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
    )
  ].join('\n')

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  downloadBlob(blob, `${filename}.csv`)
}

export async function exportDataAsJSON(
  data: any, 
  options: ExportOptions = {}
): Promise<void> {
  const { filename = 'data' } = options
  
  if (!data?.headers || !data?.rows) {
    throw new Error('No data to export')
  }

  const jsonData = data.rows.map((row: string[]) => {
    const obj: any = {}
    data.headers.forEach((header: string, index: number) => {
      obj[header] = row[index]
    })
    return obj
  })

  const jsonContent = JSON.stringify(jsonData, null, 2)
  const blob = new Blob([jsonContent], { type: 'application/json' })
  downloadBlob(blob, `${filename}.json`)
}

export async function exportDataAsExcel(
  data: any, 
  options: ExportOptions = {}
): Promise<void> {
  const { filename = 'data' } = options
  
  if (!data?.headers || !data?.rows) {
    throw new Error('No data to export')
  }

  // For Excel export, we'll create a simple CSV that can be opened in Excel
  // In a real implementation, you might use SheetJS or similar
  await exportDataAsCSV(data, { filename })
}

export async function exportDataAsTSV(
  data: any, 
  options: ExportOptions = {}
): Promise<void> {
  const { filename = 'data' } = options
  
  if (!data?.headers || !data?.rows) {
    throw new Error('No data to export')
  }

  const tsvContent = [
    data.headers.join('\t'),
    ...data.rows.map((row: string[]) => row.join('\t'))
  ].join('\n')

  const blob = new Blob([tsvContent], { type: 'text/tab-separated-values' })
  downloadBlob(blob, `${filename}.tsv`)
}

// Presentation Export Functions
export async function exportAsHTML(
  presentationData: PresentationExportData,
  options: ExportOptions = {}
): Promise<void> {
  const { charts, title, description, includeDataTable, includeInsights } = presentationData
  const { filename = 'presentation' } = options

  const html = generateHTMLPresentation(charts, title, description, includeDataTable, includeInsights)
  const blob = new Blob([html], { type: 'text/html' })
  downloadBlob(blob, `${filename}.html`)
}

export async function exportAsMarkdown(
  presentationData: PresentationExportData,
  options: ExportOptions = {}
): Promise<void> {
  const { charts, title, description } = presentationData
  const { filename = 'report' } = options

  const markdown = generateMarkdownReport(charts, title, description)
  const blob = new Blob([markdown], { type: 'text/markdown' })
  downloadBlob(blob, `${filename}.md`)
}

// Utility Functions
async function dataUrlToBlob(dataUrl: string): Promise<Blob> {
  const response = await fetch(dataUrl)
  return response.blob()
}

function canvasToSVG(canvas: HTMLCanvasElement, title?: string): string {
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">
      ${title ? `<title>${title}</title>` : ''}
      <image href="${canvas.toDataURL()}" width="${canvas.width}" height="${canvas.height}"/>
    </svg>
  `
  return svg
}


function generateHTMLPresentation(
  charts: ChartExportData[], 
  title: string, 
  description?: string,
  includeDataTable?: boolean,
  includeInsights?: boolean
): string {
  return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .chart { margin: 20px 0; text-align: center; }
        .chart img { max-width: 100%; height: auto; }
        .metadata { background: #f5f5f5; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .data-table { margin: 20px 0; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    ${description ? `<p>${description}</p>` : ''}
    
    ${charts.map((chart, index) => `
        <div class="chart">
            <h2>Chart ${index + 1}</h2>
            <img src="${chart.chart.toDataURL()}" alt="Chart ${index + 1}" />
            ${chart.metadata ? `
                <div class="metadata">
                    <p><strong>Type:</strong> ${chart.metadata.chartType}</p>
                    <p><strong>Created:</strong> ${chart.metadata.createdAt.toLocaleString()}</p>
                    <p><strong>Data Source:</strong> ${chart.metadata.dataSource}</p>
                </div>
            ` : ''}
        </div>
    `).join('')}
    
    ${includeDataTable && charts[0]?.data ? `
        <div class="data-table">
            <h2>Data Table</h2>
            <table>
                <thead>
                    <tr>
                        ${charts[0].data.headers.map((header: string) => `<th>${header}</th>`).join('')}
                    </tr>
                </thead>
                <tbody>
                    ${charts[0].data.rows.slice(0, 10).map((row: string[]) => `
                        <tr>
                            ${row.map(cell => `<td>${cell}</td>`).join('')}
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    ` : ''}
    
    <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #666;">
        <p>Generated by Datuum 2.0 on ${new Date().toLocaleString()}</p>
    </footer>
</body>
</html>
  `
}

function generateMarkdownReport(
  charts: ChartExportData[], 
  title: string, 
  description?: string
): string {
  return `# ${title}

${description ? `${description}\n` : ''}

${charts.map((chart, index) => `
## Chart ${index + 1}

![Chart ${index + 1}](data:image/png;base64,${chart.chart.toDataURL().split(',')[1]})

${chart.metadata ? `
**Chart Details:**
- Type: ${chart.metadata.chartType}
- Created: ${chart.metadata.createdAt.toLocaleString()}
- Data Source: ${chart.metadata.dataSource}
` : ''}
`).join('')}

---
*Generated by Datuum 2.0 on ${new Date().toLocaleString()}*
`
}

// Copy to Clipboard Functions
export async function copyChartToClipboard(chart: HTMLCanvasElement): Promise<void> {
  try {
    const dataUrl = chart.toDataURL('image/png')
    const response = await fetch(dataUrl)
    const blob = await response.blob()
    
    await navigator.clipboard.write([
      new ClipboardItem({
        'image/png': blob
      })
    ])
  } catch (error) {
    console.error('Failed to copy to clipboard:', error)
    throw error
  }
}

export async function copyDataToClipboard(data: any, format: 'csv' | 'json' = 'csv'): Promise<void> {
  let content: string
  
  if (format === 'csv') {
    if (!data?.headers || !data?.rows) {
      throw new Error('No data to copy')
    }
    content = [
      data.headers.join(','),
      ...data.rows.map((row: string[]) => 
        row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
      )
    ].join('\n')
  } else {
    if (!data?.headers || !data?.rows) {
      throw new Error('No data to copy')
    }
    const jsonData = data.rows.map((row: string[]) => {
      const obj: any = {}
      data.headers.forEach((header: string, index: number) => {
        obj[header] = row[index]
      })
      return obj
    })
    content = JSON.stringify(jsonData, null, 2)
  }
  
  await navigator.clipboard.writeText(content)
}
